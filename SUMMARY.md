# Effective Kotlin

- Part 1 Good Code
  - Chapter 1 Safety
    * [引言](Part 1 Good code/Chapter 1 Safety/Introduction.md)
    * [第1条：限制可变性](Part 1 Good code/Chapter 1 Safety/Item 1 Limit mutability.md)
    * [第2条：最小化变量作用域](Part 1 Good code/Chapter 1 Safety/Item 2 Minimize the scope of variables.md)
    * [第3条：尽快消除平台类型](Part 1 Good code/Chapter 1 Safety/Item 3 Eliminate platform types as soon as possible.md)
    * [第4条：不要把推断类型暴露给外部](Part 1 Good code/Chapter 1 Safety/Item 4 Do not expose inferred types.md)
    * [第5条：在参数与状态上指定你的期望](Part 1 Good code/Chapter 1 Safety/Item 5 Specify your expectations on arguments and state.md)
    * [第6条：尽可能使用标准库中提供的异常](Part 1 Good code/Chapter 1 Safety/Item 6 Prefer standard errors to custom ones.md)
    * [第7条：当不能返回预期结果时，优先使用`null` o或`Failure` 作为返回值](Part 1 Good code/Chapter 1 Safety/Item 7 Prefer null or Failure result when the lack of result is possible.md)
    * [第8条：正确地处理`null`值](Part 1 Good code/Chapter 1 Safety/Item 8 Handle nulls properly.md)
    * [第9条：使用`use`关闭资源](Part 1 Good code/Chapter 1 Safety/Item 9 Close resources with use.md)
    * [第10条：编写单元测试](Part 1 Good code/Chapter 1 Safety/Item 10 Write unit tests.md)
  - Chapter 2 Readability
    * [引言](Part 1 Good code/Chapter 2 Readability/Introduction.md)
    * [第11条：可读性设计](Part 1 Good code/Chapter 2 Readability/Item 11 Design for readability.md)
    * [Item 12 Operator Meaning Should Be Consistent With Its Function Name](Part 1 Good code/Chapter 2 Readability/Item 12 Operator meaning should be consistent with its function name.md)
    * [Item 13 Avoid Returning Or Operating On Unit](Part 1 Good code/Chapter 2 Readability/Item%2013%20Avoid%20returning%20or%20operating%20on%20Unit%3F.md)
    * [Item 14 Specify The Variable Type When It Is Not Clear](Part 1 Good code/Chapter 2 Readability/Item 14 Specify the variable type when it is not clear.md)
    * [Item 15 Consider Referencing Receivers Explicitly](Part 1 Good code/Chapter 2 Readability/Item 15 Consider referencing receivers explicitly.md)
    * [Item 16 Properties Should Represent State Not Behavior](Part 1 Good code/Chapter 2 Readability/Item 16 Properties should represent state not behavior.md)
    * [Item 17 Consider Naming Arguments](Part 1 Good code/Chapter 2 Readability/Item 17 Consider naming arguments.md)
    * [Item 18 Respect Coding Conventions](Part 1 Good code/Chapter 2 Readability/Item 18 Respect coding conventions.md)
- Part 2 Code Design
  - Chapter 3 Reusability
    * [Introduction](Part 2 Code design/Chapter 3 Reusability/Introduction.md)
    * [Item 19 Do Not Repeat Knowledge](Part 2 Code design/Chapter 3 Reusability/Item 19 Do not repeat knowledge.md)
    * [Item 20 Do Not Repeat Common Algorithms](Part 2 Code design/Chapter 3 Reusability/Item 20 Do not repeat common algorithms.md)
    * [Item 21 Use Property Delegation To Extract Common Property Patterns](Part 2 Code design/Chapter 3 Reusability/Item 21 Use property delegation to extract common property patterns.md)
    * [Item 22 Use Generics When Implementing Common Algorithms](Part 2 Code design/Chapter 3 Reusability/Item 22 Use generics when implementing common algorithms.md)
    * [Item 23 Avoid Shadowing Type Parameters](Part 2 Code design/Chapter 3 Reusability/Item 23 Avoid shadowing type parameters.md)
    * [Item 24 Consider Variance For Generic Types](Part 2 Code design/Chapter 3 Reusability/Item 24 Consider variance for generic types.md)
    * [Item 25 Reuse Between Different Platforms By Extracting Common Modules](Part 2 Code design/Chapter 3 Reusability/Item 25 Reuse between different platforms by extracting common modules.md)
  - Chapter 4 Abstraction Design
    * [Introduction](Part 2 Code design/Chapter 4 Abstraction design/Introduction.md)
    * [Item 26 Each Function Should Be Written In Terms Of A Single Level Of Abstraction](Part 2 Code design/Chapter 4 Abstraction design/Item 26 Each function should be written in terms of a single level of abstraction.md)
    * [Item 27 Use Abstraction To Protect Code Against Changes](Part 2 Code design/Chapter 4 Abstraction design/Item 27 Use abstraction to protect code against changes.md)
    * [Item 28 Specify API Stability](Part 2 Code design/Chapter 4 Abstraction design/Item 28 Specify API stability.md)
    * [Item 29 Consider Wrapping External API](Part 2 Code design/Chapter 4 Abstraction design/Item 29 Consider wrapping external API.md)
    * [Item 30 Minimize Elements Visibility](Part 2 Code design/Chapter 4 Abstraction design/Item 30 Minimize elements visibility.md)
    * [Item 31 Define Contract With Documentation](Part 2 Code design/Chapter 4 Abstraction design/Item 31 Define contract with documentation.md)
    * [Item 32 Respect Abstraction Contracts](Part 2 Code design/Chapter 4 Abstraction design/Item 32 Respect abstraction contracts.md)
  - Chapter 5 Object Creation
    * [Introduction](Part 2 Code design/Chapter 5 Object creation/Introduction.md)
    * [Item 33 Consider Factory Functions Instead Of Constructors](Part 2 Code design/Chapter 5 Object creation/Item 33 Consider factory functions instead of constructors.md)
    * [Item 34 Consider A Primary Constructor With Named Optional Arguments](Part 2 Code design/Chapter 5 Object creation/Item 34 Consider a primary constructor with named optional arguments.md)
    * [Item 35 Consider Defining A DSL For Complex Object Creation](Part 2 Code design/Chapter 5 Object creation/Item 35 Consider defining a DSL for complex object creation.md)
  - Chapter 6 Class Design
    * [Introduction](Part 2 Code design/Chapter 6 Class design/Introduction.md)
    * [Item 36 Prefer Composition Over Inheritance](Part 2 Code design/Chapter 6 Class design/Item 36 Prefer composition over inheritance.md)
    * [Item 37 Use The Data Modifier To Represent A Bundle Of Data](Part 2 Code design/Chapter 6 Class design/Item 37 Use the data modifier to represent a bundle of data.md)
    * [Item 38 Use Function Types Instead Of Interfaces To Pass Operations And Actions](Part 2 Code design/Chapter 6 Class design/Item 38 Use function types instead of interfaces to pass operations and actions.md)
    * [Item 39 Prefer Class Hierarchies To Tagged Classes](Part 2 Code design/Chapter 6 Class design/Item 39 Prefer class hierarchies to tagged classes.md)
    * [Item 40 Respect The Contract Of Equals](Part 2 Code design/Chapter 6 Class design/Item 40 Respect the contract of  equals.md)
    * [Item 41 Respect The Contract Of Hash Code](Part 2 Code design/Chapter 6 Class design/Item 41 Respect the contract of  hashCode.md)
    * [Item 42 Respect The Contract Of Compare To](Part 2 Code design/Chapter 6 Class design/Item 42 Respect the contract of compareTo.md)
    * [Item 43 Consider Extracting Non Essential Parts Of Your API Into Extensions](Part 2 Code design/Chapter 6 Class design/Item 43 Consider extracting non-essential parts of your API into extensions.md)
    * [Item 44 Avoid Member Extensions](Part 2 Code design/Chapter 6 Class design/Item 44 Avoid member extensions.md)
- Part 3 Efficiency
  - Chapter 7 Make It Cheap
    * [Introduction](Part 3 Efficiency/Chapter 7 Make it cheap/Introduction.md)
    * [Item 45 Avoid Unnecessary Object Creation](Part 3 Efficiency/Chapter 7 Make it cheap/Item 45 Avoid unnecessary object creation.md)
    * [Item 46 Use Inline Modifier For Functions With Parameters Of Functional Types](Part 3 Efficiency/Chapter 7 Make it cheap/Item 46 Use inline modifier for functions with parameters of functional types.md)
    * [Item 47 Consider Using Inline Classes](Part 3 Efficiency/Chapter 7 Make it cheap/Item 47 Consider using inline classes.md)
    * [Item 48 Eliminate Obsolete Object References](Part 3 Efficiency/Chapter 7 Make it cheap/Item 48 Eliminate obsolete object references.md)
  - Chapter 8 Efficient Collection Processing
    * [Introduction](Part 3 Efficiency/Chapter 8 Efficient collection processing/Introduction.md)
    * [Item 49 Prefer Sequence For Big Collections With More Than One Processing Step](Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 49 Prefer Sequence for big collections with more than one processing step.md)
    * [第50条：减少操作的次数](Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 50 Limit the number of operations.md)
    * [第51条：在“性能优先”的场景，考虑使用基础类型数组](Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 51 Consider Arrays with primitives for performance-critical processing.md)
    * [第52条：在处理局部变量时，考虑使用可变集合](Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 52 Consider using mutable collections.md)
