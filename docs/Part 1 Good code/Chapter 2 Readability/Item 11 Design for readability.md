## 第11条：可读性设计

在编程中，一个已知的观察结果是，开发人员阅读代码的时间远远超过编写代码的时间。一般估计是，写一分钟的代码需要阅读十分钟（这个比例在罗伯特·C·马丁的书《代码整洁之道》中得到普及）。如果你觉得这难以置信，想想你在查找错误时花费了多少时间来阅读代码。我相信每个人在自己的职业生涯中至少有一次遇到过这种情况，他们花了几个星期的时间寻找错误，最终只需改变一行代码就能修复它。当我们学习如何使用新的API时，通常是通过阅读代码来实现的。我们通常通过阅读代码来理解逻辑或实现的方式。**编程主要是关于阅读，而不是写作。**因此，我们应该以可读性为重点进行编码。

### 减少认知负荷

可读性对每个人来说意味着不同的事情。然而，有一些规则是基于经验形成的，或者来自认知科学。只需比较以下两种实现：

``` kotlin
// Implementation A
if (person != null && person.isAdult) {
   view.showPerson(person)
} else {
   view.showError()
}

// Implementation B
person?.takeIf { it.isAdult }
   ?.let(view::showPerson)
   ?: view.showError()
```

哪个更好，A还是B？使用简单的推理，认为行数较少的更好，这不是一个好答案。我们可以从第一个实现中删除换行符，它不会变得更易读。

这两种结构的可读性取决于我们能多快地理解它们。而这又在很大程度上取决于我们的大脑对每个习惯用法（结构、函数、模式）的训练程度。对于Kotlin的初学者来说，显然实现A更易读。它使用了常见的习惯用法（if/else，`&&`，方法调用）。实现B使用了Kotlin特有的习惯用法（安全调用`?.`，`takeIf`，`let`，Elvis运算符`?:`，有界函数引用`view::showPerson`）。当然，所有这些习惯用法在Kotlin中广泛使用，所以大多数有经验的Kotlin开发人员都熟悉它们。然而，很难进行比较。Kotlin并不是大多数开发人员的第一门语言，我们在一般编程方面拥有更多的经验而不是Kotlin编程方面的经验。我们编写的代码不仅是为有经验的开发人员编写的。你雇佣的初级开发人员（在经过数月的寻找高级开发人员无果之后）很可能不知道`let`、`takeIf`和有界引用是什么。他们很可能从未见过以这种方式使用Elvis运算符。这个人可能会花一整天来琢磨这个代码块。此外，即使对于有经验的Kotlin开发人员来说，他们也不只使用Kotlin这一种编程语言。让大脑识别Kotlin特定的习惯用法总是需要一些时间。即使在使用Kotlin多年之后，我仍然能够更快地理解第一个实现。每个不太常见的习惯用法都会引入一些复杂性，当我们在需要几乎同时理解所有这些习惯用法的单个语言块时，这种复杂性会累积起来。

请注意，实现方式A更容易修改。假设我们需要在if块中添加额外的操作。在实现方式A中，这样的添加很容易。在实现方式B中，我们不能再使用函数引用。在实现方式B的else块中添加内容更加困难 - 我们需要使用某个函数来能够在Elvis运算符的右侧容纳多个表达式。

``` kotlin
if (person != null && person.isAdult) {
   view.showPerson(person)
   view.hideProgressWithSuccess()
} else {
   view.showError()
   view.hideProgress()
}

person?.takeIf { it.isAdult }
   ?.let {
       view.showPerson(it)
       view.hideProgressWithSuccess()
   } ?: run {
       view.showError()
       view.hideProgress()
   }
```

调试实现方式A也要简单得多。难怪如此 - 调试工具是为这种基本结构而设计的。

一般规则是，不太常见和"创造性"的结构通常不太灵活，支持也不那么好。举个例子，假设我们需要添加第三个分支，在person为null时显示不同的错误，当person不是成年人时显示另一种错误。在实现方式A中，我们可以轻松地将if/else更改为when，使用IntelliJ的重构功能，然后轻松地添加额外的分支。而在实现方式B中，同样的更改将非常困难，可能需要完全重写。

你有没有注意到实现方式A和B甚至没有以相同的方式工作？你能看出区别吗？现在回过头来思考一下。

区别在于let从lambda表达式中返回一个结果。这意味着如果showPerson返回null，那么第二个实现方式也会调用showError！这显然不明显，它告诉我们，当我们使用不太熟悉的结构时，更容易遇到意外行为（并且很难发现）。

这里的一般规则是我们要减少认知负荷。我们的大脑识别模式，并基于这些模式构建我们对程序如何工作的理解。当我们考虑可读性时，我们希望缩短这个距离。我们更喜欢更少的代码，但也更常见的结构。当我们经常看到熟悉的模式时，我们会识别出它们。我们总是更喜欢在其他学科中熟悉的结构。

### 不要过于极端

仅仅因为在之前的例子中我演示了`let`的误用，并不意味着它应该被完全避免。`let`是一种常见的习惯用法，在各种情境下合理使用可以改善代码。一个常见的例子是当我们有一个可为空的可变属性，并且只有在它不为null时才执行某个操作。由于可变属性可能会被其他线程修改，因此无法使用智能转换。解决这个问题的一种很好的方法是使用安全调用`let`：

``` kotlin
class Person(val name: String)
var person: Person? = null

fun printName() {
    person?.let {
        print(it.name)
    }
}
```

这样的习惯用法是广为人知且使用广泛的。`let`还有很多其他合理的用例。例如：

- 将操作移到其参数计算之后
- 使用`let`将对象包装为装饰器

以下是展示这两种用例的示例（还使用了函数引用）：

``` kotlin
students
     .filter { it.result >= 50 }	
     .joinToString(separator = "\n") { 
        "${it.name} ${it.surname}, ${it.result}" 
     }
     .let(::print)

var obj = FileInputStream("/file.gz")
    .let(::BufferedInputStream)
    .let(::ZipInputStream)
    .let(::ObjectInputStream)
    .readObject() as SomeObject
```

在所有这些情况下，我们付出了一定的代价 - 这段代码更难调试，对于经验较少的Kotlin开发人员来说理解起来也更困难。但我们为此付出了代价，而且似乎是一个公平的交易。问题在于当我们为没有充分理由引入大量复杂性时。

对于某些事物是否合理将始终存在争议。在这方面取得平衡是一门艺术。然而，认识到不同的结构引入了复杂性或者使事情更加清晰是很重要的。尤其是当它们一起使用时，两种结构的复杂性通常远远超过它们各自复杂性的总和。

### 约定俗成

我们承认不同的人对可读性有不同的看法。我们经常在函数命名上争论不休，讨论什么应该是显式的，什么是隐式的，应该使用什么习语等等。编程是一门表达能力的艺术。然而，也有一些需要理解和记住的约定俗成。

当我在旧金山的一个研讨会上的一个小组问我在Kotlin中最糟糕的事情是什么时，我给了他们这个例子：

``` kotlin
val abc = "A" { "B" } and "C"
print(abc) // ABC
```

我们只需要以下代码就能实现这种可怕的语法：

``` kotlin
operator fun String.invoke(f: ()->String): String = 
    this + f()

infix fun String.and(s: String) = this + s
```

这段代码违反了我们之后将要描述的许多规则：

- 它违反了操作符的含义 - `invoke`不应该以这种方式使用。一个字符串不能被调用。
- 在这里使用“lambda作为最后一个参数”的约定会令人困惑。在函数之后使用它是可以的，但是当我们在invoke操作符上使用它时要非常小心。
- `and`显然是这个中缀方法的一个糟糕的名称。`append`或`plus`会好得多。
- 我们已经有了用于字符串连接的语言特性，应该使用它们而不是重复造轮子。


在每个建议背后，都有一条更普遍的规则来保护良好的Kotlin风格。在本章中，我们将介绍最重要的规则，从重写操作符开始讨论。