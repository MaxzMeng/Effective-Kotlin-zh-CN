
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Item 49 Prefer Sequence For Big Collections With More Than One Processing Step · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Item 50 Limit the number of operations.html" />
    
    
    <link rel="prev" href="Introduction.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Part 1 Good Code
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" >
            
                <span>
            
                    
                    Chapter 1 Safety
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" data-path="../../Part 1 Good code/Chapter 1 Safety/Introduction.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Introduction.html">
            
                    
                    引言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 1 Limit mutability.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 1 Limit mutability.html">
            
                    
                    第1条：限制可变性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.3" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 2 Minimize the scope of variables.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 2 Minimize the scope of variables.html">
            
                    
                    第2条：最小化变量作用域
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.4" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 3 Eliminate platform types as soon as possible.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 3 Eliminate platform types as soon as possible.html">
            
                    
                    第3条：尽快消除平台类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.5" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 4 Do not expose inferred types.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 4 Do not expose inferred types.html">
            
                    
                    第4条：不要把推断类型暴露给外部
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.6" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 5 Specify your expectations on arguments and state.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 5 Specify your expectations on arguments and state.html">
            
                    
                    第5条：在参数与状态上指定你的期望
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.7" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 6 Prefer standard errors to custom ones.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 6 Prefer standard errors to custom ones.html">
            
                    
                    第6条：尽可能使用标准库中提供的异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.8" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 7 Prefer null or Failure result when the lack of result is possible.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 7 Prefer null or Failure result when the lack of result is possible.html">
            
                    
                    第7条：当不能返回预期结果时，优先使用null o或Failure 作为返回值
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.9" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 8 Handle nulls properly.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 8 Handle nulls properly.html">
            
                    
                    第8条：正确地处理null值
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.10" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 9 Close resources with use.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 9 Close resources with use.html">
            
                    
                    第9条：使用use关闭资源
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.11" data-path="../../Part 1 Good code/Chapter 1 Safety/Item 10 Write unit tests.html">
            
                <a href="../../Part 1 Good code/Chapter 1 Safety/Item 10 Write unit tests.html">
            
                    
                    第10条：编写单元测试
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.2" >
            
                <span>
            
                    
                    Chapter 2 Readability
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.2.1" data-path="../../Part 1 Good code/Chapter 2 Readability/Introduction.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Introduction.html">
            
                    
                    引言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.2" data-path="../../Part 1 Good code/Chapter 2 Readability/Item 11 Design for readability.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Item 11 Design for readability.html">
            
                    
                    第11条：可读性设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.3" data-path="../../Part 1 Good code/Chapter 2 Readability/Item 12 Operator meaning should be consistent with its function name.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Item 12 Operator meaning should be consistent with its function name.html">
            
                    
                    第12条：操作符的含义应与其函数名一致
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.4" data-path="../../Part 1 Good code/Chapter 2 Readability/Item%2013%20Avoid%20returning%20or%20operating%20on%20Unit%3F.md">
            
                <span>
            
                    
                    第13条：避免返回或操作 Unit? 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.5" data-path="../../Part 1 Good code/Chapter 2 Readability/Item 14 Specify the variable type when it is not clear.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Item 14 Specify the variable type when it is not clear.html">
            
                    
                    第14条：在类型不明确的情况下，请显式指定变量的类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.6" data-path="../../Part 1 Good code/Chapter 2 Readability/Item 15 Consider referencing receivers explicitly.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Item 15 Consider referencing receivers explicitly.html">
            
                    
                    第15条：考虑明确指定接收者
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.7" data-path="../../Part 1 Good code/Chapter 2 Readability/Item 16 Properties should represent state not behavior.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Item 16 Properties should represent state not behavior.html">
            
                    
                    第16条：属性应代表状态，而不是行为
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.8" data-path="../../Part 1 Good code/Chapter 2 Readability/Item 17 Consider naming arguments.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Item 17 Consider naming arguments.html">
            
                    
                    Item 17 Consider Naming Arguments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.9" data-path="../../Part 1 Good code/Chapter 2 Readability/Item 18 Respect coding conventions.html">
            
                <a href="../../Part 1 Good code/Chapter 2 Readability/Item 18 Respect coding conventions.html">
            
                    
                    Item 18 Respect Coding Conventions
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Part 2 Code Design
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    Chapter 3 Reusability
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="../../Part 2 Code design/Chapter 3 Reusability/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 19 Do not repeat knowledge.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 19 Do not repeat knowledge.html">
            
                    
                    Item 19 Do Not Repeat Knowledge
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 20 Do not repeat common algorithms.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 20 Do not repeat common algorithms.html">
            
                    
                    Item 20 Do Not Repeat Common Algorithms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 21 Use property delegation to extract common property patterns.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 21 Use property delegation to extract common property patterns.html">
            
                    
                    Item 21 Use Property Delegation To Extract Common Property Patterns
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 22 Use generics when implementing common algorithms.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 22 Use generics when implementing common algorithms.html">
            
                    
                    Item 22 Use Generics When Implementing Common Algorithms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.6" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 23 Avoid shadowing type parameters.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 23 Avoid shadowing type parameters.html">
            
                    
                    Item 23 Avoid Shadowing Type Parameters
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.7" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 24 Consider variance for generic types.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 24 Consider variance for generic types.html">
            
                    
                    Item 24 Consider Variance For Generic Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.8" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 25 Reuse between different platforms by extracting common modules.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 25 Reuse between different platforms by extracting common modules.html">
            
                    
                    Item 25 Reuse Between Different Platforms By Extracting Common Modules
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2" >
            
                <span>
            
                    
                    Chapter 4 Abstraction Design
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.1" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.2" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 26 Each function should be written in terms of a single level of abstraction.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 26 Each function should be written in terms of a single level of abstraction.html">
            
                    
                    Item 26 Each Function Should Be Written In Terms Of A Single Level Of Abstraction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.3" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 27 Use abstraction to protect code against changes.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 27 Use abstraction to protect code against changes.html">
            
                    
                    Item 27 Use Abstraction To Protect Code Against Changes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 28 Specify API stability.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 28 Specify API stability.html">
            
                    
                    Item 28 Specify API Stability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.5" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 29 Consider wrapping external API.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 29 Consider wrapping external API.html">
            
                    
                    Item 29 Consider Wrapping External API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.6" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 30 Minimize elements visibility.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 30 Minimize elements visibility.html">
            
                    
                    Item 30 Minimize Elements Visibility
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.7" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 31 Define contract with documentation.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 31 Define contract with documentation.html">
            
                    
                    Item 31 Define Contract With Documentation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.8" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 32 Respect abstraction contracts.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 32 Respect abstraction contracts.html">
            
                    
                    Item 32 Respect Abstraction Contracts
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.3" >
            
                <span>
            
                    
                    Chapter 5 Object Creation
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.3.1" data-path="../../Part 2 Code design/Chapter 5 Object creation/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.2" data-path="../../Part 2 Code design/Chapter 5 Object creation/Item 33 Consider factory functions instead of constructors.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Item 33 Consider factory functions instead of constructors.html">
            
                    
                    Item 33 Consider Factory Functions Instead Of Constructors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.3" data-path="../../Part 2 Code design/Chapter 5 Object creation/Item 34 Consider a primary constructor with named optional arguments.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Item 34 Consider a primary constructor with named optional arguments.html">
            
                    
                    Item 34 Consider A Primary Constructor With Named Optional Arguments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.4" data-path="../../Part 2 Code design/Chapter 5 Object creation/Item 35 Consider defining a DSL for complex object creation.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Item 35 Consider defining a DSL for complex object creation.html">
            
                    
                    Item 35 Consider Defining A DSL For Complex Object Creation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.4" >
            
                <span>
            
                    
                    Chapter 6 Class Design
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.4.1" data-path="../../Part 2 Code design/Chapter 6 Class design/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.2" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 36 Prefer composition over inheritance.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 36 Prefer composition over inheritance.html">
            
                    
                    Item 36 Prefer Composition Over Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.3" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 37 Use the data modifier to represent a bundle of data.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 37 Use the data modifier to represent a bundle of data.html">
            
                    
                    Item 37 Use The Data Modifier To Represent A Bundle Of Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.4" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 38 Use function types instead of interfaces to pass operations and actions.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 38 Use function types instead of interfaces to pass operations and actions.html">
            
                    
                    Item 38 Use Function Types Instead Of Interfaces To Pass Operations And Actions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.5" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 39 Prefer class hierarchies to tagged classes.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 39 Prefer class hierarchies to tagged classes.html">
            
                    
                    Item 39 Prefer Class Hierarchies To Tagged Classes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.6" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 40 Respect the contract of  equals.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 40 Respect the contract of  equals.html">
            
                    
                    Item 40 Respect The Contract Of Equals
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.7" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 41 Respect the contract of  hashCode.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 41 Respect the contract of  hashCode.html">
            
                    
                    Item 41 Respect The Contract Of Hash Code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.8" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 42 Respect the contract of compareTo.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 42 Respect the contract of compareTo.html">
            
                    
                    Item 42 Respect The Contract Of Compare To
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.9" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 43 Consider extracting non-essential parts of your API into extensions.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 43 Consider extracting non-essential parts of your API into extensions.html">
            
                    
                    Item 43 Consider Extracting Non Essential Parts Of Your API Into Extensions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.10" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 44 Avoid member extensions.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 44 Avoid member extensions.html">
            
                    
                    Item 44 Avoid Member Extensions
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Part 3 Efficiency
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" >
            
                <span>
            
                    
                    Chapter 7 Make It Cheap
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1.1" data-path="../Chapter 7 Make it cheap/Introduction.html">
            
                <a href="../Chapter 7 Make it cheap/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.2" data-path="../Chapter 7 Make it cheap/Item 45 Avoid unnecessary object creation.html">
            
                <a href="../Chapter 7 Make it cheap/Item 45 Avoid unnecessary object creation.html">
            
                    
                    Item 45 Avoid Unnecessary Object Creation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.3" data-path="../Chapter 7 Make it cheap/Item 46 Use inline modifier for functions with parameters of functional types.html">
            
                <a href="../Chapter 7 Make it cheap/Item 46 Use inline modifier for functions with parameters of functional types.html">
            
                    
                    Item 46 Use Inline Modifier For Functions With Parameters Of Functional Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.4" data-path="../Chapter 7 Make it cheap/Item 47 Consider using inline classes.html">
            
                <a href="../Chapter 7 Make it cheap/Item 47 Consider using inline classes.html">
            
                    
                    Item 47 Consider Using Inline Classes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.5" data-path="../Chapter 7 Make it cheap/Item 48 Eliminate obsolete object references.html">
            
                <a href="../Chapter 7 Make it cheap/Item 48 Eliminate obsolete object references.html">
            
                    
                    Item 48 Eliminate Obsolete Object References
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.2" >
            
                <span>
            
                    
                    Chapter 8 Efficient Collection Processing
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="Introduction.html">
            
                <a href="Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.2.2" data-path="Item 49 Prefer Sequence for big collections with more than one processing step.html">
            
                <a href="Item 49 Prefer Sequence for big collections with more than one processing step.html">
            
                    
                    Item 49 Prefer Sequence For Big Collections With More Than One Processing Step
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="Item 50 Limit the number of operations.html">
            
                <a href="Item 50 Limit the number of operations.html">
            
                    
                    第50条：减少操作的次数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="Item 51 Consider Arrays with primitives for performance-critical processing.html">
            
                <a href="Item 51 Consider Arrays with primitives for performance-critical processing.html">
            
                    
                    第51条：在“性能优先”的场景，考虑使用基础类型数组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.5" data-path="Item 52 Consider using mutable collections.html">
            
                <a href="Item 52 Consider using mutable collections.html">
            
                    
                    第52条：在处理局部变量时，考虑使用可变集合
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Item 49 Prefer Sequence For Big Collections With More Than One Processing Step</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="item-49-prefer-sequence-for-big-collections-with-more-than-one-processing-step">Item 49: Prefer Sequence for big collections with more than one processing step</h2>
<p>People often miss the difference between <code>Iterable</code> and <code>Sequence</code>. It is understandable since even their definitions are nearly identical:</p>
<pre><code class="lang-kotlin">interface Iterable<span class="hljs-type">&lt;out T&gt;</span> {
   operator <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span>: Iterator<span class="hljs-type">&lt;T&gt;</span></span>
}

interface Sequence<span class="hljs-type">&lt;out T&gt;</span> {
   operator <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span>: Iterator<span class="hljs-type">&lt;T&gt;</span></span>
}
</code></pre>
<p>You can say that the only formal difference between them is the name. Although <code>Iterable</code> and <code>Sequence</code> are associated with totally different usages (have different contracts), so nearly all their processing functions work in a different way. <code>Sequences</code> are lazy, so intermediate functions for <code>Sequence</code> processing don&#x2019;t do any calculations. Instead, they return a new <code>Sequence</code> that decorates the previous one with the new operation. All these computations are evaluated during a terminal operation like <code>toList</code> or <code>count</code>. Iterable processing, on the other hand, returns a collection like <code>List</code> on every step. </p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">filter</span><span class="hljs-params">(
   predicate: <span class="hljs-type">(T</span>)</span> -&gt; <span class="hljs-keyword">Boolean</span></span>
): List<span class="hljs-type">&lt;T&gt;</span> {
   <span class="hljs-keyword">return</span> filterTo(ArrayList<span class="hljs-type">&lt;T&gt;</span>(), predicate)
}

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Sequence<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">filter</span><span class="hljs-params">(
   predicate: <span class="hljs-type">(T</span>)</span> -&gt; <span class="hljs-keyword">Boolean</span></span>
): Sequence<span class="hljs-type">&lt;T&gt;</span> {
   <span class="hljs-keyword">return</span> FilteringSequence(this, <span class="hljs-literal">true</span>, predicate)
}
</code></pre>
<p>As a result, collection processing operations are invoked once they are used. <code>Sequence</code> processing functions are not invoked until the terminal operation (an operation that returns something else but <code>Sequence</code>). For instance, for <code>Sequence</code>, <code>filter</code> is an intermediate operation, so it doesn&#x2019;t do any calculations, but instead, it decorates the sequence with the new processing step. Calculations are done in a terminal operation like <code>toList</code>.</p>
<p><img src="../../assets/chapter8/chapter8-2.png" alt=""></p>
<pre><code> 1 val seq = sequenceOf(1,2,3)
 2 val filtered = seq.filter { print(&quot;f$it &quot;); it % 2 == 1 }
 3 println(filtered)  // FilteringSequence@...
 4 
 5 val asList = filtered.toList() 
 6 // f1 f2 f3
 7 println(asList) // [1, 3]
 8 
 9 val list = listOf(1,2,3)
10 val listFiltered = list
11   .filter { print(&quot;f$it &quot;); it % 2 == 1 } 
12 // f1 f2 f3
13 println(listFiltered) // [1, 3]
</code></pre><p>There are a few important advantages of the fact that sequences are lazy in Kotlin:</p>
<ul>
<li>They keep the natural order of operations</li>
<li>They do a minimal number of operations</li>
<li>They can be infinite</li>
<li>They do not need to create collections at every step</li>
</ul>
<p>Let&#x2019;s talk about those advantages one-by-one.</p>
<h3 id="order-is-important">Order is important</h3>
<p>Because of how iterable and sequence processing are implemented, the ordering of their operations is different. In sequence processing, we take the first element and apply all the operations, then we take the next element, and so on. We will call it an element-by-element or lazy order. In iterable processing, we take the first operation and we apply it to the whole collection, then move to the next operation, etc.. We will call it step-by-step or eager order. </p>
<pre><code> 1 sequenceOf(1,2,3)
 2        .filter { print(&quot;F$it, &quot;); it % 2 == 1 }
 3        .map { print(&quot;M$it, &quot;); it * 2 }
 4        .forEach { print(&quot;E$it, &quot;) }
 5 // Prints: F1, M1, E2, F2, F3, M3, E6, 
 6 
 7 listOf(1,2,3)
 8        .filter { print(&quot;F$it, &quot;); it % 2 == 1 }
 9        .map { print(&quot;M$it, &quot;); it * 2 }
10        .forEach { print(&quot;E$it, &quot;) }
11 // Prints: F1, F2, F3, M1, M3, E2, E6,
</code></pre><p><img src="../../assets/chapter8/chapter8-3.png" alt=""></p>
<p>Notice that, if we were to implement those operations without any collection processing functions, but instead using classic loops and conditions, we would have element-by-element order like in sequence processing:</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">for</span> (e <span class="hljs-keyword">in</span> listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) {
   print(<span class="hljs-string">&quot;F$e, &quot;</span>)
   <span class="hljs-keyword">if</span>(e % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
       print(<span class="hljs-string">&quot;M$e, &quot;</span>)
       <span class="hljs-variable"><span class="hljs-keyword">val</span> mapped</span> = e * <span class="hljs-number">2</span>
       print(<span class="hljs-string">&quot;E$mapped, &quot;</span>)
   }
}
<span class="hljs-comment">// Prints: F1, M1, E2, F2, F3, M3, E6,</span>
</code></pre>
<p>Therefore element-by-element order that is used in sequence processing is more natural. It also opens the door for low-level compiler optimizations - sequence processing can be optimized to basic loops and conditions. Maybe in the future, it will be. </p>
<h3 id="sequences-do-the-minimal-number-of-operations">Sequences do the minimal number of operations</h3>
<p>Often we do not need to process the whole collection at every step to produce the result. Let&#x2019;s say that we` have a collection with millions of elements, and after processing, we only need to take the first 10. Why process all the other elements? Iterable processing doesn&#x2019;t have the concept of intermediate operations, so the whole collection is processed as if it were to be returned on every operation. Sequences do not need that, and so they will do the minimal number of operations required to get the result. </p>
<p><img src="../../assets/chapter8/chapter8-4.png" alt=""></p>
<p>Take a look at the example, where we have a few processing steps and we end our processing with <code>find</code>:</p>
<pre><code class="lang-kotlin">(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).asSequence()
   .filter { print(<span class="hljs-string">&quot;F$it, &quot;</span>); it % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> }
   .map { print(<span class="hljs-string">&quot;M$it, &quot;</span>); it * <span class="hljs-number">2</span> }
   .find { it &gt; <span class="hljs-number">5</span> }
<span class="hljs-comment">// Prints: F1, M1, F2, F3, M3,</span>

(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>)
   .filter { print(<span class="hljs-string">&quot;F$it, &quot;</span>); it % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> }
   .map { print(<span class="hljs-string">&quot;M$it, &quot;</span>); it * <span class="hljs-number">2</span> }
   .find { it &gt; <span class="hljs-number">5</span> }
<span class="hljs-comment">// Prints: F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, </span>
<span class="hljs-comment">// M1, M3, M5, M7, M9,</span>
</code></pre>
<p>For this reason, when we have some intermediate processing steps and our terminal operation does not necessarily need to iterate over all elements, using a sequence will most likely be better for the performance of your processing. All that while looking nearly the same as the standard collection processing. Examples of such operations are <code>first</code>, <code>find</code>, <code>take</code>, <code>any</code>, <code>all</code>, <code>none</code> or <code>indexOf</code>.</p>
<h3 id="sequences-can-be-infinite">Sequences can be infinite</h3>
<p>Thanks to the fact that sequences do processing on-demand, we can have infinite sequences. A typical way to create an infinite sequence is using sequence generators like <code>generateSequence</code> or <code>sequence</code>. The first one needs the first element and a function specifying how to calculate the next one:</p>
<pre><code class="lang-kotlin">generateSequence(<span class="hljs-number">1</span>) { it + <span class="hljs-number">1</span> }
       .map { it * <span class="hljs-number">2</span> }
       .take(<span class="hljs-number">10</span>)
       .forEach { print(<span class="hljs-string">&quot;$it, &quot;</span>) }
<span class="hljs-comment">// Prints: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,</span>
</code></pre>
<p>The second mentioned sequence generator - <code>sequence</code> - uses a suspending function (coroutine<a href="chap65.xhtml#fn-coroutine">2</a>) that generates the next number on demand. Whenever we ask for the next number, the sequence builder runs until a value is yielded using <code>yield</code>. The execution then stops until we ask for another number. Here is an infinite list of the next Fibonacci numbers:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> fibonacci</span> = sequence {
   yield(<span class="hljs-number">1</span>)
   <span class="hljs-variable"><span class="hljs-keyword">var</span> current</span> = <span class="hljs-number">1</span>
   <span class="hljs-variable"><span class="hljs-keyword">var</span> prev</span> = <span class="hljs-number">1</span>
   <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
       yield(current)
       <span class="hljs-variable"><span class="hljs-keyword">val</span> temp</span> = prev
       prev = current
       current += temp
   }
}

print(fibonacci.take(<span class="hljs-number">10</span>).toList()) 
<span class="hljs-comment">// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span>
</code></pre>
<p>Notice that infinite sequences need to have a limited number of elements at some point. We cannot iterate over infinity. </p>
<pre><code class="lang-kotlin">print(fibonacci.toList()) <span class="hljs-comment">// Runs forever</span>
</code></pre>
<p>Therefore we either need to limit them using an operation like <code>take</code>, or we need to use a terminal operation that will not need all elements, like <code>first</code>, <code>find</code>, <code>any</code>, <code>all</code>, <code>none</code> or <code>indexOf</code>. Basically, those are the same operations for which sequences are more efficient because they do not need to process all elements. Although notice that for most of those operations, it is easy to fall into an infinite loop. <code>any</code> can only return <code>true</code> or run forever. Similarly <code>all</code> and <code>none</code> can only return <code>false</code> on an infinite collection. As a result, we generally either limit the number of elements by <code>take</code>, or we ask for just the first element using <code>first</code>.</p>
<h3 id="sequences-do-not-create-collections-at-every-processing-step">Sequences do not create collections at every processing step</h3>
<p>Standard collection processing functions return a new collection at every step. Most often it is a <code>List</code>. This could be an advantage - after every point, we have something ready to be used or stored. But it comes at a cost. Such collections need to be created and filled with data on every step. </p>
<pre><code class="lang-kotlin">numbers
   .filter { it % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> } <span class="hljs-comment">// 1 collection here</span>
   .map { it * <span class="hljs-number">2</span> } <span class="hljs-comment">// 1 collection here</span>
   .sum() 
<span class="hljs-comment">// In total, 2 collections created under the hood</span>

numbers
   .asSequence()
   .filter { it % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> }
   .map { it * <span class="hljs-number">2</span> }
   .sum() 
<span class="hljs-comment">// No collections created</span>
</code></pre>
<p>This is a problem especially when we are dealing with big or heavy collections. Let&#x2019;s start from an extreme and yet common case: file reading. Files can weigh gigabytes. Allocating all the data in a collection at every processing step would be a huge waste of memory. This is why by default we use sequences to process files. </p>
<p>As an example, let&#x2019;s analyze crimes in the Chicago city. This city, like many others, shared on the internet the whole database of crimes that took place there since 2001<a href="chap65.xhtml#fn-footnote_81_note">3</a>. This dataset at the moment weights over 1.53 GB. Let&#x2019;s say that our task is to find how many crimes had cannabis in their descriptions. This is what a naive solution using collection processing would look like (<code>readLines</code> returns <code>List&lt;String&gt;</code>):</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// BAD SOLUTION, DO NOT USE COLLECTIONS FOR </span>
<span class="hljs-comment">// POSSIBLY BIG FILES</span>
File(<span class="hljs-string">&quot;ChicagoCrimes.csv&quot;</span>).readLines()
   .drop(<span class="hljs-number">1</span>) <span class="hljs-comment">// Drop descriptions of the columns</span>
   .mapNotNull { it.split(<span class="hljs-string">&quot;,&quot;</span>).getOrNull(<span class="hljs-number">6</span>) } 
    <span class="hljs-comment">// Find description</span>
   .filter { <span class="hljs-string">&quot;CANNABIS&quot;</span> <span class="hljs-keyword">in</span> it } 
   .count()
   .let(::println)
</code></pre>
<p>The result on my computer is <code>OutOfMemoryError</code>. </p>
<p>Exception in thread &#x201C;main&#x201D; java.lang.OutOfMemoryError: Java heap space</p>
<p>No wonder why. We create a collection and then we have 3 intermediate processing steps, which add up to 4 collections. 3 out of them contain the majority of this data file, which takes 1.53 GB, so they all need to consume more than 4.59 GB. This is a huge waste of memory. The correct implementation should involve using a sequence, and we do that using the function <code>useLines</code> that always operates on a single line:</p>
<pre><code class="lang-kotlin">File(<span class="hljs-string">&quot;ChicagoCrimes.csv&quot;</span>).useLines { lines -&gt;
<span class="hljs-comment">// The type of `lines` is Sequence&lt;String&gt;</span>
   lines
       .drop(<span class="hljs-number">1</span>) <span class="hljs-comment">// Drop descriptions of the columns</span>
       .mapNotNull { it.split(<span class="hljs-string">&quot;,&quot;</span>).getOrNull(<span class="hljs-number">6</span>) } 
       <span class="hljs-comment">// Find description</span>
       .filter { <span class="hljs-string">&quot;CANNABIS&quot;</span> <span class="hljs-keyword">in</span> it } 
       .count()
       .let { println(it) } <span class="hljs-comment">// 318185</span>
}
</code></pre>
<p>On my computer it took 8.3s. To compare the efficiency of both ways, I made another experiment and I reduced this dataset size by dropping columns I don&#x2019;t need. This way I achieved <code>CrimeData.csv</code> file with the same crimes but with a size of only 728 MB. Then I did the same processing. In the first implementation, using collection processing, it takes around 13s; while the second one, using sequences, around 4.5s. As you can see, using sequences for bigger files is not only for memory but also for performance. </p>
<p>Although a collection does not need to be heavy. The fact that in every step we are creating a new collection is also a cost in itself, and this cost manifests itself when we are dealing with collections with a larger number of elements. The difference is not huge - mainly because created collections after many steps are initialized with the expected size and so when we add elements we just place them in the next position. This difference is still substantial, and it is the main reason why we should <strong>prefer to use Sequence for big collections with more than one processing step</strong>. </p>
<p>By &#x201C;big collections&#x201D; I mean both many elements and really heavy collection. It might be a list of integers with tens of thousands of elements. It might also be a list with just a few strings, but so each long that they all take many megabytes of data. Those are not common situations, but they sometimes happen. </p>
<p>By one processing step, I mean more than a single function for collection processing. So if you compare these two functions:</p>
<pre><code class="lang-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">singleStepListProcessing</span><span class="hljs-params">()</span>: List<span class="hljs-type">&lt;Product&gt;</span> {</span>
   <span class="hljs-keyword">return</span> productsList.filter { it.bought }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">singleStepSequenceProcessing</span><span class="hljs-params">()</span>: List<span class="hljs-type">&lt;Product&gt;</span> {</span>
   <span class="hljs-keyword">return</span> productsList.asSequence()
           .filter { it.bought }
           .toList()
}
</code></pre>
<p>You will notice that there is nearly no difference in performance (actually simple list processing is faster because its <code>filter</code> function is inline). Although when you compare functions with more than one processing step, like the functions below, which use the <code>filter</code> and then <code>map</code>, the difference will be visible for bigger collections. To see a difference, let&#x2019;s compare typical processing with two and three processing steps for 5000 products:</p>
<pre><code class="lang-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">twoStepListProcessing</span><span class="hljs-params">()</span>: List<span class="hljs-type">&lt;Double&gt;</span> {</span>
   <span class="hljs-keyword">return</span> productsList
           .filter { it.bought }
           .map { it.price }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">twoStepSequenceProcessing</span><span class="hljs-params">()</span>: List<span class="hljs-type">&lt;Double&gt;</span> {</span>
   <span class="hljs-keyword">return</span> productsList.asSequence()
           .filter { it.bought }
           .map { it.price }
           .toList()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">threeStepListProcessing</span><span class="hljs-params">()</span>: <span class="hljs-keyword">Double</span> {</span>
   <span class="hljs-keyword">return</span> productsList
           .filter { it.bought }
           .map { it.price }
           .average()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">threeStepSequenceProcessing</span><span class="hljs-params">()</span>: <span class="hljs-keyword">Double</span> {</span>
   <span class="hljs-keyword">return</span> productsList.asSequence()
           .filter { it.bought }
           .map { it.price }
           .average()
}
</code></pre>
<p>Below you can see the average results on a MacBook Pro (Retina, 15-inch, Late 2013)<a href="chap65.xhtml#fn-footnote_82_note">4</a> for 5000 products in the <code>productsList</code>:</p>
<pre><code class="lang-kotlin">twoStepListProcessing                        <span class="hljs-number">81</span> <span class="hljs-number">095</span> ns
twoStepSequenceProcessing                    <span class="hljs-number">55</span> <span class="hljs-number">685</span> ns
twoStepListProcessingAndAcumulate            <span class="hljs-number">83</span> <span class="hljs-number">307</span> ns
twoStepSequenceProcessingAndAcumulate         <span class="hljs-number">6</span> <span class="hljs-number">928</span> ns
</code></pre>
<p>It is hard to predict what performance improvement we should expect. From my observations, in a typical collection processing with more than one step, for at least a couple of thousands of elements, we can expect around a 20-40% performance improvement. </p>
<h3 id="when-arent-sequences-faster">When aren&#x2019;t sequences faster?</h3>
<p>There are some operations where we don&#x2019;t profit from this sequence usage because we have to operate on the whole collection either way. <code>sorted</code> is an example from Kotlin stdlib (currently it is the only example). <code>sorted</code> uses optimal implementation: It accumulates the <code>Sequence</code> into <code>List</code> and then uses <code>sort</code> from Java stdlib. The disadvantage is that this accumulation process takes some additional time if we compare it to the same processing on a <code>Collection</code>(although if Iterable is not a <code>Collection</code> or array, then the difference is not significant because it needs to be accumulated as well).</p>
<p>It is controversial if <code>Sequence</code> should have methods like <code>sorted</code> because sequences with a method requiring all elements to calculate the next one are only partially lazy (evaluated when we need to get the first element) and don&#x2019;t work on infinite sequences. It was added because it is a popular function and it is much easier to use it in this way. Although Kotlin developers should remember its flaws, and especially that it cannot be used on infinite sequences.</p>
<pre><code class="lang-kotlin">generateSequence(<span class="hljs-number">0</span>) { it + <span class="hljs-number">1</span> }.take(<span class="hljs-number">10</span>).sorted().toList() 
<span class="hljs-comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
generateSequence(<span class="hljs-number">0</span>) { it + <span class="hljs-number">1</span> }.sorted().take(<span class="hljs-number">10</span>).toList() 
<span class="hljs-comment">// Infinite time. Does not return.</span>
</code></pre>
<p><code>sorted</code> is a rare example of processing step which is faster on <code>Collection</code> than on <code>Sequence</code>. Still, when we do a few processing steps and single sorted function (or other function that needs to work on the whole collection), we can expect a performance improvement using sequence processing.</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// Benchmarking measurement result: 150 482 ns </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">productsSortAndProcessingList</span><span class="hljs-params">()</span>: <span class="hljs-keyword">Double</span> {</span>
    <span class="hljs-keyword">return</span> productsList.sortedBy { it.price }
        .filter { it.bought }
        .map { it.price }
        .average()
}

<span class="hljs-comment">// Benchmarking measurement result: 96 811 ns </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">productsSortAndProcessingSequence</span><span class="hljs-params">()</span>: <span class="hljs-keyword">Double</span> {</span>
    <span class="hljs-keyword">return</span> productsList.asSequence()
        .sortedBy { it.price }
        .filter { it.bought }
        .map { it.price }
        .average()

}
</code></pre>
<h3 id="what-about-java-stream">What about Java stream?</h3>
<p>Java 8 introduced streams to allow collection processing. They act and look similar to Kotlin sequences.</p>
<pre><code class="lang-kotlin">productsList.asSequence()
       .filter { it.bought }
       .map { it.price }
       .average()

productsList.stream()
       .filter { it.bought }
       .mapToDouble { it.price }
       .average()
       .orElse(<span class="hljs-number">0.0</span>)
</code></pre>
<p>Java 8 streams are lazy and collected in the last (terminal) processing step. Three big differences between Java streams and Kotlin sequences are the following:</p>
<ul>
<li>Kotlin sequences have many more processing functions (because they are defined as extension functions) and they are generally easier to use (this is a result of the fact that Kotlin sequences were designed when Java streams was already used&#x200A;&#x2014;&#x200A;for instance we can collect using <code>toList()</code> instead of <code>collect(Collectors.toList())</code>)</li>
<li>Java stream processing can be started in parallel mode using a parallel function. This can give us a huge performance improvement in contexts when we have a machine with multiple cores that are often unused (which is common nowadays). Although use this with caution as this feature has known pitfalls<a href="chap65.xhtml#fn-paralell_stream">5</a>.</li>
<li>Kotlin sequences can be used in common modules, Kotlin/JVM, Kotlin/JS, and Kotlin/Native modules. Java streams only in Kotlin/JVM, and only when the JVM version is at least 8.</li>
</ul>
<p>In general, when we don&#x2019;t use parallel mode, it is hard to give a simple answer which of Java stream or Kotlin sequence is more efficient. My suggestion is to use Java streams rarely, only for computationally heavy processing where you can profit from the parallel mode. Otherwise, use Kotlin stdlib functions to have a homogeneous and clean code that can be used in different platforms or on common modules.</p>
<h3 id="kotlin-sequence-debugging">Kotlin Sequence debugging</h3>
<p>Both Kotlin Sequence and Java Stream have the support that helps us debug elements flow at every step. For Java Stream, it requires a plugin named &#x201C;Java Stream Debugger&#x201D;. Kotlin Sequences also required plugin named &#x201C;Kotlin Sequence Debugger&#x201D;, though now this functionality is integrated into Kotlin plugin. Here is a screen showing sequence processing at every step:</p>
<p><img src="../../assets/chapter8/chapter8-5.png" alt=""></p>
<h3 id="summary">Summary</h3>
<p>Collection and sequence processing are very similar and both support nearly the same processing methods. Yet there are important differences between the two. Sequence processing is harder, as we generally keep elements in collections and so changing to collections requires a transformation to sequence and often also back to the desired collection. Sequences are lazy, which brings some important advantages:</p>
<ul>
<li>They keep the natural order of operations</li>
<li>They do a minimal number of operations</li>
<li>They can be infinite</li>
<li>They do not need to create collections at every step</li>
</ul>
<p>As a result, they are better to process heavy objects or for bigger collections with more than one processing step. Sequences are also supported by Kotlin Sequence Debugger that can help us by visualizing how elements are processed. Sequences are not to replace classic collection processing. You should use them only when there&#x2019;s a good reason to, and you&#x2019;ll be rewarded with significant performance optimization.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Introduction.html" class="navigation navigation-prev " aria-label="Previous page: Introduction">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Item 50 Limit the number of operations.html" class="navigation navigation-next " aria-label="Next page: 第50条：减少操作的次数">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Item 49 Prefer Sequence For Big Collections With More Than One Processing Step","level":"1.4.2.2","depth":3,"next":{"title":"第50条：减少操作的次数","level":"1.4.2.3","depth":3,"path":"Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 50 Limit the number of operations.md","ref":"Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 50 Limit the number of operations.md","articles":[]},"previous":{"title":"Introduction","level":"1.4.2.1","depth":3,"path":"Part 3 Efficiency/Chapter 8 Efficient collection processing/Introduction.md","ref":"Part 3 Efficiency/Chapter 8 Efficient collection processing/Introduction.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 49 Prefer Sequence for big collections with more than one processing step.md","mtime":"2023-08-24T15:13:50.516Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-08-24T15:14:40.456Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

